Term.equal.aux: UFind -> Defs -> List(<B: Type> -> (Term -> Term -> Nat -> B) -> B) -> Pair(UFind)(Bool)
  (uf) (defs) (tris) tris<() Pair(UFind)(Bool)>
  | Pair.new<UFind><Bool>(uf)(Bool.true);
  | (tris.head) (tris.tail) tris.head<Pair(UFind)(Bool)>
    | (a0) (b0) (depth)
      let a1 = Term.reduce(a0)(defs)
      let b1 = Term.reduce(b0)(defs)
      let eq = Term.congruent(uf)(a1)(b1)
      let uf = Term.equate(uf)(a0)(a1)
      let uf = Term.equate(uf)(b0)(b1)
      let uf = Term.equate(uf)(a1)(b1)
      let cons = List.cons<<B: Type> -> (Term -> Term -> Nat -> B) -> B>
      let nil = List.nil<<B: Type> -> (Term -> Term -> Nat -> B) -> B>
      let concat = List.concat<<B: Type> -> (Term -> Term -> Nat -> B) -> B>
      eq<() Pair(UFind)(Bool)>
      | Term.equal.aux(uf)(defs)(tris.tail);
      | a1<() Pair(UFind)(Bool)>
        | (a1.hash) (a1.indx) Pair.new<UFind><Bool>(uf)(Bool.false);
        | (a1.hash) (a1.name) Pair.new<UFind><Bool>(uf)(Bool.false);
        | (a1.hash) Pair.new<UFind><Bool>(uf)(Bool.false);
        | (a1.hash) (a1.eras) (a1.self) (a1.name) (a1.bind) (a1.body) a1<() Pair(UFind)(Bool)> // All
          | (b1.hash) (b1.indx) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.name) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.eras) (b1.self) (b1.name) (b1.bind) (b1.body)
            Bool.and(Bool.eql(a1.eras)(b1.eras))(String.eql(a1.self)(b1.self))<() Pair(UFind)(Bool)>
            | Pair.new<UFind><Bool>(uf)(Bool.false);
            | let children = cons(<> (f) f(a1.bind)(b1.bind)(Nat.succ(depth)))(
                cons(<> (f) f(a1.body)(b1.body)(Nat.succ(Nat.succ(depth))))(nil))
              let list = concat(tris.tail)(children)
              Term.equal.aux(uf)(defs)(list);;
          | (b1.hash) (b1.eras) (b1.name) (b1.body) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.eras) (b1.func) (b1.argm) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.name) (b1.expr) (b1.body) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.done) (b1.expr) (b1.type) Pair.new<UFind><Bool>(uf)(Bool.false);
        ;
        | (a1.hash) (a1.eras) (a1.name) (a1.body) a1<() Pair(UFind)(Bool)> // Lam
          | (b1.hash) (b1.indx) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.name) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.eras) (b1.self) (b1.name) (b1.bind) (b1.body) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.eras) (b1.name) (b1.body)
            Bool.eql(a1.eras)(b1.eras)<() Pair(UFind)(Bool)>
            | Pair.new<UFind><Bool>(uf)(Bool.false);
            | let children = cons(<B> (f) f(a1.body)(b1.body)(Nat.succ(depth)))(nil)
              let list = concat(tris.tail)(children)
              Term.equal.aux(uf)(defs)(list);;
          | (b1.hash) (b1.eras) (b1.func) (b1.argm) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.name) (b1.expr) (b1.body) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.done) (b1.expr) (b1.type) Pair.new<UFind><Bool>(uf)(Bool.false);;
        | (a1.hash) (a1.eras) (a1.func) (a1.argm) a1<() Pair(UFind)(Bool)> // App
          | (b1.hash) (b1.indx) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.name) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.eras) (b1.self) (b1.name) (b1.bind) (b1.body) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.eras) (b1.name) (b1.body) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.eras) (b1.func) (b1.argm)
            Bool.eql(a1.eras)(b1.eras)<() Pair(UFind)(Bool)>
            | Pair.new<UFind><Bool>(uf)(Bool.false);
            | let children = cons(<B> (f) f(a1.func)(b1.func)(depth))(
                cons(<B> (f) f(a1.argm)(b1.argm)(depth))(nil))
              let list = concat(tris.tail)(children)
              Term.equal.aux(uf)(defs)(list);;
          | (b1.hash) (b1.name) (b1.expr) (b1.body) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.done) (b1.expr) (b1.type) Pair.new<UFind><Bool>(uf)(Bool.false);;
        | (a1.hash) (a1.name) (a1.expr) (a1.body) a1<() Pair(UFind)(Bool)> // Let
          | (b1.hash) (b1.indx) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.name) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.eras) (b1.self) (b1.name) (b1.bind) (b1.body) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.eras) (b1.name) (b1.body) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.eras) (b1.func) (b1.argm) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.name) (b1.expr) (b1.body)
            let children = cons(<B> (f) f(a1.expr)(b1.expr)(depth))(
              cons(<B> (f) f(a1.body)(b1.body)(Nat.succ(depth)))(nil))
            let list = concat(tris.tail)(children)
            Term.equal.aux(uf)(defs)(list);
          | (b1.hash) (b1.done) (b1.expr) (b1.type) Pair.new<UFind><Bool>(uf)(Bool.false);;
        | (a1.hash) (a1.done) (a1.expr) (a1.type) a1<() Pair(UFind)(Bool)> // Ann
          | (b1.hash) (b1.indx) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.name) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.eras) (b1.self) (b1.name) (b1.bind) (b1.body) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.eras) (b1.name) (b1.body) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.eras) (b1.func) (b1.argm) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.name) (b1.expr) (b1.body) Pair.new<UFind><Bool>(uf)(Bool.false);
          | (b1.hash) (b1.done) (b1.expr) (b1.type)
            let children = cons(<B> (f) f(a1.expr)(b1.expr)(Nat.succ(depth)))(nil)
            let list = concat(tris.tail)(children)
            Term.equal.aux(uf)(defs)(list);;;;;
