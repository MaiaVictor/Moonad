Term.congruent: UFind -> Term -> Term -> Bool
  (uf) (t) (s)
  let path1 = U32.to_bits(Term.hash(t))
  let path2 = U32.to_bits(Term.hash(s))
  let eq = UFind.equivalent(uf)(path1)(path2)
  eq<() Bool>
  | Bool.true;
  | t<() Bool>
    | (t.hash) (t.indx) Bool.false;
    | (t.hash) (t.name) Bool.false;
    | (t.hash) Bool.false;
    | (t.hash) (t.eras) (t.self) (t.name) (t.bind) (t.body) s<() Bool> // All
      | (s.hash) (s.indx) Bool.false;
      | (s.hash) (s.name) Bool.false;
      | (s.hash) Bool.false;
      | (s.hash) (s.eras) (s.self) (s.name) (s.bind) (s.body)
        Bool.and(Bool.eql(t.eras)(s.eras))(
          Bool.and(String.eql(t.self)(s.self))(
            Bool.and(Term.congruent(uf)(t.bind)(s.bind))(
              Term.congruent(uf)(t.body)(s.body))));
      | (s.hash) (s.eras) (s.name) (s.body) Bool.false;
      | (s.hash) (s.eras) (s.func) (s.argm) Bool.false;
      | (s.hash) (s.name) (s.expr) (s.body) Bool.false;
      | (s.hash) (s.done) (s.expr) (s.type) Bool.false;
    ;
    | (t.hash) (t.eras) (t.name) (t.body) s<() Bool> // Lam
      | (s.hash) (s.indx) Bool.false;
      | (s.hash) (s.name) Bool.false;
      | (s.hash) Bool.false;
      | (s.hash) (s.eras) (s.self) (s.name) (s.bind) (s.body) Bool.false;
      | (s.hash) (s.eras) (s.name) (s.body)
        Bool.and(Bool.eql(t.eras)(s.eras))(
          Term.congruent(uf)(t.body)(s.body));
      | (s.hash) (s.eras) (s.func) (s.argm) Bool.false;
      | (s.hash) (s.name) (s.expr) (s.body) Bool.false;
      | (s.hash) (s.done) (s.expr) (s.type) Bool.false;;
    | (t.hash) (t.eras) (t.func) (t.argm) s<() Bool> // App
      | (s.hash) (s.indx) Bool.false;
      | (s.hash) (s.name) Bool.false;
      | (s.hash) Bool.false;
      | (s.hash) (s.eras) (s.self) (s.name) (s.bind) (s.body) Bool.false;
      | (s.hash) (s.eras) (s.name) (s.body) Bool.false;
      | (s.hash) (s.eras) (s.func) (s.argm)
        Bool.and(Bool.eql(t.eras)(s.eras))(
          Bool.and(Term.congruent(uf)(t.func)(s.func))(
            Term.congruent(uf)(t.argm)(s.argm)));
      | (s.hash) (s.name) (s.expr) (s.body) Bool.false;
      | (s.hash) (s.done) (s.expr) (s.type) Bool.false;;
    | (t.hash) (t.name) (t.expr) (t.body) s<() Bool> // Let
      | (s.hash) (s.indx) Bool.false;
      | (s.hash) (s.name) Bool.false;
      | (s.hash) Bool.false;
      | (s.hash) (s.eras) (s.self) (s.name) (s.bind) (s.body) Bool.false;
      | (s.hash) (s.eras) (s.name) (s.body) Bool.false;
      | (s.hash) (s.eras) (s.func) (s.argm) Bool.false;
      | (s.hash) (s.name) (s.expr) (s.body)
        Bool.and(Term.congruent(uf)(t.body)(s.body))(
          Term.congruent(uf)(t.expr)(s.expr));
      | (s.hash) (s.done) (s.expr) (s.type) Bool.false;;
    | (t.hash) (t.done) (t.expr) (t.type) s<() Bool> // Ann
      | (s.hash) (s.indx) Bool.false;
      | (s.hash) (s.name) Bool.false;
      | (s.hash) Bool.false;
      | (s.hash) (s.eras) (s.self) (s.name) (s.bind) (s.body) Bool.false;
      | (s.hash) (s.eras) (s.name) (s.body) Bool.false;
      | (s.hash) (s.eras) (s.func) (s.argm) Bool.false;
      | (s.hash) (s.name) (s.expr) (s.body) Bool.false;
      | (s.hash) (s.done) (s.expr) (s.type)
        Term.congruent(uf)(t.expr)(s.expr);;;